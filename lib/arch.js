var Q = require('qq'),
    INHERIT = require('inherit'),
    Plan = require('./plan'),
    util = require('./util'),
    arraySlice = Array.prototype.slice,

    nodeIDSequence = 1;

module.exports = INHERIT({

    /**
     * Create an instance of Arch.
     *
     * @constructor
     */
    __constructor: function() {
        this.nodes = {};
        this.parents = {};
        this.children = {};
        this.plans = {};
    },

    /**
     * Apply function on this Arch.
     *
     * @param {Function} fn Function to apply.
     * @returns {Arch} this.
     */
    apply: function(fn) {
        fn.apply(this, arraySlice.call(arguments, 1));
        return this;
    },

    /**
     * Lock this arch and it's plans.
     */
    lock: function() {
        this.locked = true;

        for (var k in this.plans) {
            this.plans[k].lock();
        }
    },

    /**
     * Unlock this arch and its plans.
     */
    unlock: function() {
        this.locked = false;

        for (var k in this.plans) {
            this.plans[k].unlock();
        }
    },

    /**
     * Call function inside lock()/unlock() pair.
     *
     * @param {Function} cb Function to call.
     * @param {Object} context Call context.
     * @returns {promise} The result of Q.when().fin().
     */
    withLock: function(cb, context) {
        var _this = this;
        this.lock();
        return Q.when(cb.apply(context))
            .fin(function() {
                _this.unlock();
            });
    },

    /**
     * Add new node.
     * If id argument is absent, autogenerated ID will be used.
     *
     * @param {String} [id] Node ID.
     * @param {Object} node Node to add.
     * @param {String[]|String} [parents] Parent node IDs to link with.
     * @param {String[]|String} [children] Child node IDs to link with.
     * @returns {String} Node ID.
     */
    setNode: function(id, node, parents, children) {
        if (id && typeof id !== 'string') {
            children = parents;
            parents = node;
            node = id;
            id = null;
        }
        if (!id) id = (node.getId && node.getId())? node.getId() : nodeIDSequence++;

        this.nodes[id] = node;

        // TODO: seems like copy-paste between parents and childs
        // Proposal: add private method for both link types management
        if (!this.parents[id] || (parents && parents !== true)) this.parents[id] = [];
        if (parents && parents !== true) {
            this.link([id], parents);
        }

        if (!this.children[id] || (children && children !== true)) this.children[id] = [];
        if (children && children !== true) {
            this.link(children, [id]);
        }

        return id;
    },

    /**
     * Replace node 'body'.
     *
     * @param {String} id ID of node to replace.
     * @param {Object} node New node.
     * @returns {String} Node ID.
     */
    replaceNode: function(id, node) {
        var args = arraySlice.call(arguments);
        args = (args.length < 2? [null] : []).concat(args, [true, true]);
        return this.setNode.apply(this, args);
    },

    /**
     * Check if node with such ID exists in this arch.
     *
     * @param {String} id Node ID to check.
     * @returns {boolean} True if exists, otherwise false.
     */
    hasNode: function(id) {
        return !!this.nodes[id];
    },

    /**
     * Return node by ID.
     * If there are no such node, return default node.
     *
     * @param {String} id Node id
     * @returns {Object} Node object
     */
    getNode: function(id) {
        return this.hasNode(id)? this.nodes[id] : this.getDefaultNode(id);
    },

    /**
     * Create and return stub node for ID.
     * NB: it is not belongs to this Arch, just utility function.
     *
     * @param {String} id ID of node to create.
     * @returns {Object} Object with .getId() and .run() inside.
     */
    getDefaultNode: function(id) {
        return {
            getId: function() {
                return id;
            },

            run: function() {
                return Q.reject("** No rule to make target '" + id + "'");
            }
        };
    },

    /**
     * Return node children IDs.
     *
     * @param {String} id Node ID.
     * @returns {String[]} Children IDs.
     */
    getChildrenIds: function(id) {
        return [].concat(this.children[id] || []);
    },

    /**
     * Return node parent IDs.
     *
     * @param {String} id Node ID.
     * @returns {String[]} Parent IDs.
     */
    getParentsIds: function(id) {
        return [].concat(this.parents[id] || []);
    },

    /**
     * Link nodes.
     *
     * @param {String[]|String} children IDs of child nodes.
     * @param {String[]|String} parents IDs of parent nodes.
     */
    link: function(children, parents) {
        parents = util.toArray(parents);
        util.toArray(children).forEach(function(child) {
            this._link(child, parents);
        }, this);
    },

    /**
     * Link child node with parents.
     *
     * @param {String} child Child node ID.
     * @param {String[]} parents Parent nodes IDs.
     */
    _link: function(child, parents) {
        var _parents = this.parents[child],
            parent,
            children;

        for (var i = 0; i < parents.length; i++) {
            parent = parents[i];
            children = this.children[parent] || (this.children[parent] = []);

            if (_parents.indexOf(parent) === -1) _parents.push(parent);
            if (children.indexOf(child) === -1) children.push(child);

            for (var k in this.plans) {
                var p = this.plans[k];
                if (p.hasNode(child) || p.hasNode(parent)) p.link(child, parent);
            }
        }
    },

    /**
     * Unlink linked (child-parent) nodes.
     *
     * @param {String} id1 First node ID to unlink.
     * @param {String} id2 Second node ID to unlink.
     */
    unlink: function(id1, id2) {
        util.unlink(this.parents[id1], this.children[id1], id2);
        util.unlink(this.parents[id2], this.children[id2], id1);

        for (var k in this.plans) {
            var p = this.plans[k];
            if (p.hasNode(id1) && p.hasNode(id2)) p.unlink(id1, id2);
        }
    },

    /**
     * Remove node from arch.
     *
     * @param {String} id Node ID to remove.
     */
    removeNode: function(id) {
        util.removeNode(this.children, this.parents, id);

        delete this.nodes[id];

        for (var k in this.plans) {
            var p = this.plans[k];
            if (p.hasNode(id)) p.removeNode(id);
        }
    },

    /**
     * Create plan instance from this arch.
     * Targets are (is) node IDs to run. If you have A -> B -> C arch and it is needed to build 'A', you target is 'A'.
     *
     * @param {String[]|String} targets Node IDs to build.
     * @returns {Plan} Created plan.
     */
    createPlan: function(targets) {
        return new Plan(this, targets, '__plan_root__');
    },

    /**
     * Register plan in this arch.
     *
     * @param {Plan} plan Plan to register.
     */
    registerPlan: function(plan) {
        this.plans[plan.getId()] = plan;
    },

    /**
     * Unregister plan in this arch.
     *
     * @param {Plan} plan Plan to unregister.
     */
    unregisterPlan: function(plan) {
        delete this.plans[plan.getId()];
    },

    /**
     * Return IDs of root (without parents) nodes.
     *
     * @returns {String[]} IDs of root nodes.
     */
    findRoots: function() {
        return Object.keys(this.parents).filter(function(id) {
            return !this.parents[id].length;
        }, this);
    },

    /**
     * Dump this arch to string for debug purposes.
     *
     * @returns {String} String representation of this arch.
     */
    toString: function() {
        return 'Graph:\n' +
            this.findRoots().map(function(r) {
                    return '== root\n' + this.nodeToString(r, ' ')
                }, this).join('')
    },

    /**
     * Dump node with its children to string.
     *
     * @param {String} id Node ID to dump.
     * @param {String} spaces Left indent spaces.
     */
    nodeToString: function(id, spaces) {
        spaces = spaces || ' ';

        return spaces + id + '\n' +
            this.children[id].map(function(c) {
                    return spaces + this.nodeToString(c, spaces + ' ')
                }, this).join('')
    }

});
