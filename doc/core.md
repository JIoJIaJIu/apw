Кратко ход выполнения:

 1. Инициализация графа со всеми целями.
 2. Выделение плана выполнения.
 3. Выполнение плана.

Граф (**Graph**/[graph.js](https://github.com/afelix/sandbox2/blob/master/lib/parts/graph.js "graph.js")) содержит в себе все цели сборки и связи между ними. Цель (parent) не выполнится, пока не отработают успешно её дети (children).

![Graph](https://github.com/afelix/sandbox2/raw/master/doc/graph.png)

Для выполнения цели из графа выделяется план выполнения (**Plan**/[plan.js](https://github.com/afelix/sandbox2/blob/master/lib/parts/plan.js "plan.js")). Он содержит в себе копию подграфа без лишних ссылок. На картинке ниже план выполнения цели 'C'.

![Plan](https://github.com/afelix/sandbox2/raw/master/doc/plan.png)

Основная задача плана — выдавать в правильном порядке цели для выполнения. В примере выше последовательность приведёт к вот такому исходнику (не именно такой, только иллюстрирует):

    plan.nextJob(); // -> 'E'
    plan.nextJob(); // -> 'G'
    plan.nextJob(); // -> 'D', если успешно выполнился 'E'
    plan.nextJob(); // -> 'F', если успешно выполнился 'G'
    plan.nextJob(); // -> 'C', если успешно выполнились 'D' и 'F'

Выполнением целей заведует сущность **Jobs**/[jobs.js](https://github.com/afelix/sandbox2/blob/master/lib/parts/jobs.js "jobs.js"). Именно она запрашивает у плана следующую цель и контролирует процесс запуска. Здесь же срабатывает ограничение на количество worker'ов (одновременно запущенных процессов).

У пользовательского кода (того, что в коде целей) есть следующие пути влияния на выполнение:

 * Редактирование графа. Любое изменение отражается также на планах, потому цель попадает в пул выполнения, если она связана с целями плана.
 * Возвращение результата выполнения. Если всё ok, план продолжает выполняться. Если fail, выполнение останавливается.