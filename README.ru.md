APW (arch-plan-workers) является ядром системы сборки, в которой:

 * узлы графа целей могут менять граф
 * узлы решают, собирать им себя или нет
 * процесс сборки асинхронный

Конфигурационные файлы (конфиги) пишутся на языке JavaScript. Широко используется библиотека promises [Q](https://github.com/kriskowal/q).

## Пример использования

Демонстрационный пример элементарного конфига:

```js
var APW = require('apw');

exports.getArch = function() {
    var arch = new APW.Arch();

    arch.setNode('all', { run: function() { console.log('all: done') }});
    arch.setNode('compile', { run: function() { console.log('compile: done') }}, 'all');
    arch.setNode('test', { run: function() { console.log('test: done') }}, 'compile');

    return arch;
};
```

Запуск:

    apw -f make.js

Результат:

    test: done
    compile: done
    all: done

Пример сложного конфига: [github.com/bem/bem-tools](https://github.com/bem/bem-tools/tree/server)

## Установка

Перед установкой следует убедиться, что уже установлены:

 * Node.js (platform built on Chrome's JavaScript runtime) — [nodejs.org](http://nodejs.org)
 * npm (package manager for node) — [npmjs.org](http://npmjs.org/)

Модулем для API/require (рекомендуемый вариант):

    npm install apw

Для использования в command-line:

    npm install apw -g

## Детальнее

### Основные понятия:

 * **Arch** (архитектура) — граф сборки, в котором каждая задача (или target в терминах make) является узлом (**Node**). Он собирает в себя абсолютно все задачи вне зависимости от того, будут ли они выполняться или нет.
 * **Node** (узел) — в общем случае отделяемая и предназначенная для выполнения задача. Например, валидация CSS, сборка файла документации, запуск тестов и т.п. Код узла может порождать новые узлы и совершать иные манипуляции с графом.
 * **Plan** (план) — план выполнения последовательности задач. Он определяет, какая следующая задача будет отправлена на выполнение.
 * **Workers** (исполнители) — сущности, фактически выполняющие задачи.

### Как это работает?

Пользователь создаёт конфиг с обязательным `exports.getArch` — эта функция должна вернуть экземпляр **Arch**.

Пользователь запускает сборку указанной задачи (например, `test`) либо из командной строки, либо из JavaScript кода.

Из переданного графа apw выделяет план сборки для `test`. Он включает в себя все актуальные на тот момент зависимости.

План передаётся на выполнение исполнителям. Если в процессе выполнения в графе появляются новые задачи и они связаны с задачами, входящими в план, план дополняется.

Если хотя бы одна задача не завершилась успешно, выполнение прекращается.

## Написание конфига

Минимальный конфиг, с помощью которого можно проверить, всё ли верно установлено, выглядит так:

```js
var APW = require('apw');

exports.getArch = function() {
    return new APW.Arch();
};
```

Результат при выполнении:

    ** No rule to make target 'all'

Имеет смысл заполнить граф задачами. На этапе инициализации графа это делается с помощью функций `Arch.setNode()` и `Arch.link()`.

## API

### Основные сущности

#### id

Уникальный строковый идентификатор вашей задачи в графе, её имя. Используется для поиска, удаления, связывания и т.п. Помимо того, что apw различает задачи по `id`, вам может оказаться удобным использовать его для собственных специальных целей, например, для определения типа задачи по собственной схеме именования.

#### node

Объект, который и является задачей. В большинстве случаев задача выглядит так:

```js
{
    run: function(ctx) { .. do something .. }
}
```

Функция `run` запускается `apw` на этапе выполнения задачи. Её аргументом `ctx` является контекст — объект, включающий в себя `jobs`, `plan`, `arch`. Наиболее важным и используемым для задач является `arch` — выполняемая задача может изменить граф сборки (что отразится на планах), добавить новые задачи, удалить ненужные, перекомпоновать зависимости.

#### parent

Задача-родитель, зависит от задачи-ребёнка (`child`) и не выполняется, пока не выполнится ребёнок. У задачи может и не быть явного родителя.

#### child

Задача-ребёнок, блокирует выполнение родителя (`parent`), пока не выполнится сама.

### Arch

**setNode(id, node, parents, children)** — добавляет задачу в граф.

`id` — string, уникальный идентификатор задачи.

`node` — object, сама задача.

`parents` — string, `id` родителя, **или** array, список `id` родителей.

`children` — string, `id` ребёнка, **или** array, список `id` детей.

**link(children, parents)** — связывает задачи.

`children` — string, `id` ребёнка, **или** array, список `id` детей.

`parents` — string, `id` родителя, **или** array, список `id` родителей.

**unlink(id1, id2)** — удаляет связь между парой задач.

`id1` — string, уникальный идентификатор одной задачи.

`id2` — string, уникальный идентификатор другой задачи.